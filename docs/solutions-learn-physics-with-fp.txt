-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Please see the README on GitHub at
--   <a>https://github.com/ezoerner/solutions-learn-physics-with-fp#README.md</a>
@package solutions-learn-physics-with-fp
@version 0.1.0.0


module Chapter01


module Chapter02

-- | <pre>
--   f(x) = √ (1 + x)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; f 0
--   1.0
--   
--   &gt;&gt;&gt; f 1
--   1.4142135623730951
--   
--   &gt;&gt;&gt; f 3
--   2.0
--   </pre>
f :: Floating a => a -> a

-- | Standard Earth gravity acceleration at sea level in m/s².
stdGravityMPS2 :: Double

-- | Assuming an initial velocity of 30 m/s, accepts as input the time
--   (after the rock was thrown) in seconds and gives as output the height
--   of the rock in meters.
yRock30 :: Double -> Double

-- | Accepts as input the time (after the rock was thrown) in seconds and
--   gives as output the upward velocity of the rock in meters per second.
--   A downward velocity is returned as a negative number.
vRock30 :: Double -> Double

-- | Computes the sine of an angle given in degrees.
--   
--   <pre>
--   &gt;&gt;&gt; sinDeg 30
--   0.49999999999999994
--   </pre>
sinDeg :: Double -> Double

-- | <pre>
--   f(x) = ∛x
--   </pre>
f25 :: Double -> Double

-- | <pre>
--   g(ɣ) = e^ɣ+8^ɣ
--   </pre>
g :: Double -> Double

-- | <pre>
--   h(x) = 1/√((x-5)²+16)
--   </pre>
h :: Double -> Double

-- | <pre>
--   ɣ(β) = 1/√(1 - β²)
--   </pre>
ɣ :: Double -> Double

-- | <pre>
--   U(x) = 1/(10+x)+1(10-x)
--   </pre>
bigU :: Double -> Double

-- | <pre>
--   L(l) = √(l(l + 1))
--   </pre>
bigL :: Double -> Double

-- | <pre>
--   E(x) = 1 / (|x|³)
--   </pre>
bigEx :: Double -> Double

-- | <pre>
--   E(z) = 1 / (z²+4)^(3/2)
--   </pre>
bigEz :: Double -> Double


module Chapter03

-- | <pre>
--   f(x) = { 0, x ≤ 0; x, x &gt; 0}
--   </pre>
f :: Double -> Double

-- | <pre>
--   E(r) = { r, r ≤ 1; 1/r², r &gt; 1}
--   </pre>
e :: Double -> Double

-- | Returns <a>True</a> if the input character is <tt>'X'</tt> or
--   <tt>'Y'</tt> or else <a>False</a>.
--   
--   <pre>
--   &gt;&gt;&gt; isXorY 'X'
--   True
--   
--   &gt;&gt;&gt; isXorY 'Y'
--   True
--   
--   &gt;&gt;&gt; isXorY 'Z'
--   False
--   </pre>
isXorY :: Char -> Bool

-- | Returns <tt>100</tt> if the person is checking bags and <tt>0</tt> if
--   not. Implemented with <tt>if-then-else</tt>.
bagFee :: Bool -> Int

-- | Returns <tt>100</tt> if the person is checking bags and <tt>0</tt> if
--   not. Implemented with pattern matching on the input.
bagFee2 :: Bool -> Int

-- | Returns <a>True</a> if the given integer is greater than 50 or else
--   <a>False</a>
greaterThan50 :: Integer -> Bool

-- | Double the score without going over 100
--   
--   <pre>
--   &gt;&gt;&gt; amazingCurve 30
--   60
--   
--   &gt;&gt;&gt; amazingCurve 80
--   100
--   </pre>
amazingCurve :: Int -> Int

-- | <pre>
--   circleRadius = 3.5
--   </pre>
circleRadius :: Double

-- | <pre>
--   cot x = 1 / tan x
--   </pre>
cot :: Double -> Double

-- | <pre>
--   fe epsilon = epsilon * tan (epsilon * pi / 2)
--   </pre>
fe :: Double -> Double

-- | <pre>
--   fo epsilon = -epsilon * cot (epsilon * pi / 2)
--   </pre>
fo :: Double -> Double

-- | <pre>
--   g nu epsilon = sqrt (nu ** 2 - epsilon ** 2)
--   </pre>
g :: Double -> Double -> Double


module Chapter04

-- | alias R to be a Double as an approximate of a real number
type R = Double

-- | A derivative is a function of a real to real that yields another
--   function of real to real
type Derivative = (R -> R) -> R -> R

-- | Numerical derivation given a small delta
derivative :: R -> Derivative

-- | <pre>
--   f(x) = ½x²
--   </pre>
f41 :: R -> R

-- | <pre>
--   f(x) = x³
--   </pre>
f42 :: R -> R

-- | Derivative of <a>f42</a>, <tt>f(x) = 3x²</tt>.
df42 :: R -> R

-- | Error function: Returns the error between a numerical derivative
--   estimate and the provided analytical derivative.
errF :: (R -> R) -> (R -> R) -> R -> R -> R

-- | Error function for <a>f42</a>.
err42 :: R -> R -> R

-- | Returns the error in terms of <tt>a</tt> (the "delta"). The expression
--   for the error is apparantly <tt>a²/4</tt>. This formula was just
--   determined empirically by putting a bunch of <tt>a</tt> values into
--   <a>err42</a> and looking at the pattern of results.
errA :: R -> R
f44 :: R -> R
df44 :: R -> R

module Chapter05
sndItem0 :: [a] -> a
repeatInt :: Int -> [Int]
null' :: [a] -> Bool
last' :: [a] -> a
palindrome :: String -> Bool
cycle' :: [a] -> [a]
type R = Double
euler :: R
pi' :: R
fact :: Integer -> Integer
expList :: R -> [R]
calcSeriesLengthWithinPercent :: (R -> [R]) -> (R -> R) -> R -> R -> Maybe Int
expSeries :: R -> [R]

module Chapter06
type R = Double
yRock :: R -> R -> R
vRock :: R -> R -> R

-- | Exercise 6.4.
greaterThanOrEq7' :: Int -> Bool

-- | Exercise 6.5. True if and only if s has length &gt; n
isLongerThan :: Int -> String -> Bool

-- | Exercise 6.6. Has more than 6 elements
hasMoreThan6Elements :: [a] -> Bool

-- | Exercise 6.8.
first1000Squares :: [Integer]

-- | Exercise 6.9.
repeat' :: a -> [a]

-- | Exercise 6.10.
replicate' :: Int -> a -> [a]

module Chapter07
type R = Double
plot1 :: IO ()
plot2 :: IO ()
plot3 :: IO ()
